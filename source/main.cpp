// Include the most common headers from the C standard library
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <iostream>
#include <string>
#include <sstream>
#include <fstream>
#include <iomanip>

// Include the main libnx system header, for Switch development
#include <switch.h>
#include <errno.h>

using namespace std;

// Uncomment this line to show log
// #define SHOW_LOG 1

#ifdef SHOW_LOG
static void initConsole(PadState *pad)
{
    consoleInit(NULL);
    padConfigureInput(1, HidNpadStyleSet_NpadStandard);
    
    padInitializeDefault(pad);
    consoleUpdate(NULL);
    printf("Press A to launch Web applet.\n");
    printf("Press + to exit.\n");
}

static void exitConsole(void)
{
    // Deinitialize and clean up resources used by the console (important!)
    consoleExit(NULL);
}
#endif

void readfile(const char* path, char * url)
{
    FILE* f = fopen(path, "r");
    if (f)
    {
        fgets(url, 8182, f);
        fclose(f);
    } else {
        printf("errno is %d, %s\n", errno, strerror(errno));
    }
}

AccountUid uid;
string AccountID;
FsFileSystem savedata;

std::string FormatHex128(AccountUid Number){
  auto ptr = reinterpret_cast<u8*>(Number.uid);
  std::stringstream strm;
  strm << std::hex << std::uppercase;
  for(u32 i = 0; i < 16; i++) strm << (u32)ptr[i];
  return strm.str();
}

std::string string_to_hex(const std::string& in) {
  std::stringstream ss;

  ss << std::hex << std::setfill('0');
  for (size_t i = 0; in.length() > i; ++i) {
    ss << std::setw(2) << static_cast<unsigned int>(static_cast<unsigned char>(in[i]));
  }
  return ss.str();
}

bool GetUserID() {
  if(accountUidIsValid(&uid)) {
    AccountID = FormatHex128(uid);
    cout << "Gotted user uid:"<< AccountID.c_str() <<std::endl;
    return true;
  }
  cout << "Failied to get user ID" <<std::endl;
  return false;
}

bool initUser() {
  Result rc = 0;
  setsysInitialize();
  setInitialize();

  rc = accountInitialize(AccountServiceType_Administrator);
  if (R_SUCCEEDED(rc)) {
    accountGetPreselectedUser(&uid);
    if(!accountUidIsValid(&uid)) {
      cout <<"U:2" <<std::endl;
      accountTrySelectUserWithoutInteraction (&uid, false);
    }

    if(!accountUidIsValid(&uid)) {
      cout <<"U:3" <<std::endl;
      accountGetLastOpenedUser (&uid);
    }

    if(!accountUidIsValid(&uid)) {
      cout <<"U:4" <<std::endl;
      accountGetLastOpenedUser (&uid);
    }

    cout <<"User Init OK" <<std::endl;
    return GetUserID();
  } else {
    cout << "Failied to init User" <<std::endl;
    return false;
  }
}

// Get and save browser cookies
bool GetCookies(){
  FsFileSystem dataW;
  bool stateS = true;
  if(R_SUCCEEDED(fsOpen_SystemSaveData(&dataW,FsSaveDataSpaceId_System, 0x8000000000001071, uid))) {
    fsdevMountDevice("bro", dataW);
    std::string path = "bro:/Cookie.dat";

    std::ifstream inf(path);
    if(!inf.fail()) {
      std::string tempcookie="";
      for(int f = 0; !inf.eof(); f++)
      {
        string TempLine = "";
        getline(inf, TempLine);
        tempcookie += TempLine;
      }
      inf.close();

      string cookiestr="#Cookies Generated by Browser\n\n";
      int r = 8,t=0,s=tempcookie.size();
      while (t<3 && r < s)
      {
        string hexd = string_to_hex(tempcookie.substr(r,1));
        if (hexd != "00"){
          cookiestr+=tempcookie.substr(r,1);
          t=0;
        } else {
          cookiestr+="\n";
          t++;
        }
        r++;
      }
      std::ofstream otf("sdmc:/COOKIES_WEB_APPLET.txt");
      otf << cookiestr;
      otf.close();
      std::cout << "Cookie Imported... size " << cookiestr.size() << std::endl;
    } else {
      stateS = false;
    }
    fsdevUnmountDevice("bro");
  }else{
    printf("Cookie not Readed... \n");
    stateS = false;
  }

  fsFsClose(&dataW);
  return stateS;
}

void openBrowser(const char* url)
{
    Result rc = 0;
    WebCommonConfig config;
    WebCommonReply reply;
    WebExitReason exitReason = (WebExitReason)0;

    // Create the config. There's a number of web*Create() funcs, see libnx web.h.
    // webPageCreate/webNewsCreate requires running under a host Application which has HtmlDocument content. When the host program is an Application when using webPageCreate/webNewsCreate, and webConfigSetWhitelist is not used, the whitelist will be loaded from the content. AtmosphÃ¨re hbl_html can be used to handle this.
    if (strlen(url) == 0){
        rc = webPageCreate(&config, "http://dns.switchbru.com");
    } else {
        rc = webPageCreate(&config, url);
    }
    printf("webPageCreate(): 0x%x\n", rc);

    if (R_SUCCEEDED(rc)) {
        // At this point you can use any webConfigSet* funcs you want.
        webConfigSetUid(&config, uid);
        webConfigSetCallbackUrl(&config, "http://localhost/");
        // webConfigSetFooterFixedKind(&config, WebFooterFixedKind_Hidden);
        webConfigSetWebAudio(&config, true);
        webConfigSetMediaAutoPlay(&config, true);
        webConfigSetMediaPlayerUi(&config, true);
        webConfigSetTouchEnabledOnContents(&config, true);
        webConfigSetBootAsMediaPlayer(&config, true);
        webConfigSetMediaPlayerSpeedControl (&config, true);
        webConfigSetMediaPlayerAutoClose (&config, false);
        webConfigSetJsExtension(&config, true);
        webConfigSetPageCache(&config, true);
        webConfigSetPageScrollIndicator(&config, true);
        webConfigSetScreenShot(&config, true);

        if (R_SUCCEEDED(rc)) { // Launch the applet and wait for it to exit.
            printf("Running webConfigShow...\n");
            rc = webConfigShow(&config, &reply); // If you don't use reply you can pass NULL for it.
            printf("webConfigShow(): 0x%x\n", rc);
        }

        if (R_SUCCEEDED(rc)) { // Normally you can ignore exitReason.
            rc = webReplyGetExitReason(&reply, &exitReason);
            printf("webReplyGetExitReason(): 0x%x", rc);
            if (R_SUCCEEDED(rc)) {
                printf(", 0x%x", exitReason);
                if (exitReason == WebExitReason_LastUrl) {
                    char lastUrl[1024];
                    size_t lastUrlLen;
                    rc = webReplyGetLastUrl(&reply, lastUrl, 1024, &lastUrlLen);
                    if (R_SUCCEEDED(rc)) printf("lastUrl: %lu|%s\n", lastUrlLen, lastUrl);
                } else if (exitReason == 0x06) {
                    // close from player
                } else if (exitReason == 0x0f) {
                    // timeout
                }
            }
            printf("\n");
        }
    }
}

// Main program entrypoint
int main(int argc, char* argv[])
{
    char url[8182];
    Result rc=0;
    memset(url, 0, sizeof(url));

#ifdef SHOW_LOG
    PadState pad;
    initConsole(&pad);
    atexit(exitConsole);
#endif

    rc = romfsInit();
    if (R_FAILED(rc))
        printf("romfsInit: %08X\n", rc);
    else
    {
        printf("romfs Init Successful!\n");
        readfile("romfs:/weblink.txt", url);
        printf("url: %s\n", url);
    }

    initUser();

    // Main loop
    while (appletMainLoop())
    {
#ifdef SHOW_LOG        
        // Scan the gamepad. This should be done once for each frame
        padUpdate(&pad);

        // padGetButtonsDown returns the set of buttons that have been
        // newly pressed in this frame compared to the previous one
        u64 kDown = padGetButtonsDown(&pad);

        if (kDown & HidNpadButton_Plus)
            break; // break in order to return to hbmenu

        if (kDown & HidNpadButton_A) {
            openBrowser(url);
        }

        // Update the console, sending a new frame to the display
        consoleUpdate(NULL);
#else
        openBrowser(url);
#endif
    }

    // Get and write cookies to sdmc
    // GetCookies();
    accountExit();
    setExit();
    setsysExit();
    return 0;
}
